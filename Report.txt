Fulton Wilcox (frw14) & Sean Patrick (smp429)
Project Report

Need to submit as PDF

1)
API Implementation:

int worker_create(worker_t * thread, pthread_attr_t * attr, void *(*function)(void*), void * arg):

    The job of worker_create is to create the tcb for a worker thread and initialize the main context and shceduler context if it is the first call of the session.
    The first thing that is done is allocate the memory for the tcb, call create_tcb which initializes its fields and makes it ready to run, and add it to the runqueue.
    If this is the first call of worker_create of the session, there will also be a call to create the scheduler and main benchmark threads. 

    
int worker_yield():

    worker_yield turns over control of the process to the scheduler, taking away control from the currently running thread.  The tcb's status field is changed back to 
    "ready" from "running", and the context is swapped back to the scheduler context.

    
void worker_exit(void *value_ptr):

    worker_exit is the mechanism by which a thread should terminate according to the framework of this library.  The argument, a void pointer, is passed in to store the return
    value of the function if there is one.  the status of the thread is changed to "terminated" from "running" and the time is recorded and saved in the tcb for the app statistics.
    The turnaround and response time is also recorded, and the average response and turnaround time updated.  

    
int worker_join(worker_t thread, void **value_ptr):

    worker_join blocks the calling thread until the thread whose thread id is passed into the function terminates.  First, the thread that is passed into the function is found by
    searching through the queues, and the function lingers until the status of this thread is terminated.  Once it is terminated, we know the thread can now continue, 
    so the function can return. The return value, if the function isn't void, is also storted in value_ptr.
    
int worker_mutex_init(worker_mutex_t *mutex, const pthread_mutexattr_t *mutexattr):

    
int worker_mutex_lock(worker_mutex_t *mutex):

    
int worker_mutex_unlock(worker_mutex_t *mutex):

    
int worker_mutex_destroy(worker_mutex_t *mutex):

    
static void schedule():

    schedule is the main scheduler function to which the scheduler context is assigned to and to which the thread library is built on.  The first thing done in the schedule function is to 
    disable the timer so the scheduler is not interrupted.  The scheduler then calls the function corresponding to what the selected scheduling policy is, which will store the next thread to 
    run in curThread.  The status of this thread is changed to "running", the timer is enabled, and the thread is run.  Once the scheduler context takes control again, the thread will be changed
    back to a status of ready if it is not blocked or terminated, and it will be added to the corresponding queue.

    
static void sched_psjf():

    
static void sched_mlfq():

static void create_tcb(worker_t * thread, tcb* control_block, void *(*function)(void*), void * arg);

    The purpose of this function is to modularize the population of a tcb.  A new context is created, the stack for the new tcb is created, and the fields such as thread id, status, and stack are 
    populated within the tcb.  The context in the tcb is then assigned to the given function.

tcb* enqueue(tcb *thread, tcb *queue):

    This is a function to add a new tcb to the given queue.  It either assigns the pointer of the queue to the pointer of the thread if the queue is empty, or traverses to the end of the queue and 
    appends the thread.

tcb* dequeue(tcb *queue):

    Function to dequeue from the given queue.
    
static tcb* search(worker_t thread, tcb* queue):

    This function searches for the thread corresponding to the given thread id in the given queue.  It returns the tcb upon a search hit and returns null upon a search miss.

int isEmpty(tcb *queue):

    Abstraction to verify if queue is empty

void printQueue(tcb *queue):

    Helper function to print the queue by their thread id's

void toString(tcb *thread):

    Helper function to print information about a thread

static void signal_handler(int signum):
 
static void enable_timer():

    Function to enable the timer

static void disable_timer():

    Function to disable timer by setting parameters to 0

void setup_timer():

    Function to set up timer.  Timer is assigned to the signal handler function, the time parameters are set up, and setitimer is called.

int scheduler_benchmark_create_context():

    This function is called upon the very first call of worker_create.  The scheduler and benchmark context are created, the benchmark context is assigned 
    a tcb while the scheduler context is stored in a global variable.  setup_timer is also called, and control is handed over to the scheduler context.

2)
Benchmark Results:

MLFQ:
    external_cal.c:

    5 threads: runtime: 632 microseconds, context switches: 159, turnaround: 436, response: 23
    10 threads: runtime: 585 microseconds, context switches: 186, turnaround: 403.181818, response: 33.272727
    20 threads: runtime: 580 microseconds, context switches: 180, turnaround: 221.380952, response: 25.571429
    50 threads: runtime: 551 microseconds, context switches: 152, turnaround: 136.960784, response: 69.098039
    100 threads: runtime: 544 microseconds, context switches: 262, turnaround: 57.108911, response: 15.673267

    parallel_cal.c:

    5 threads: runtime: 26413 microseconds, context switches: 2199, turnaround: 7847.166667, response: 24.666667
    10 threads: runtime: 25659 microseconds, context switches: 2284, turnaround: 8532.181818, response: 68.818182
    20 threads: runtime: 23512 microseconds, context switches: 1716, turnaround: 6570.476190, response: 144.476190
    50 threads: runtime: 17502 microseconds, context switches: 1618, turnaround: 5358.666667, response: 355.058824
    100 threads: runtime: 16355 microseconds, context switches: 1750, turnaround: 5278.801980, response: 796.693069

    vector_multiply.c:

    5 threads: runtime: 49 microseconds, context switches: 9, turnaround: 21.333333, response: 16.166667
    10 threads: runtime: 50 microseconds, context switches: 14, turnaround: 25.818182, response: 22.727273
    20 threads: runtime: 51 microseconds, context switches: 24, turnaround: 28.428571, response: 26.904762
    50 threads: runtime: 54 microseconds, context switches: 54, turnaround: 30.235294, response: 29.509804
    100 threads: runtime: 52 microseconds, context switches: 104, turnaround: 28.504950, response: 28.148515

PSJF:
    external_cal.c:

    5 threads: runtime: 633 microseconds, context switches: 143, turnaround: 444.833333, response: 24
    10 threads: runtime: 655 microseconds, context switches: 216, turnaround: 469.545455, response: 47
    20 threads: runtime: 595 microseconds, context switches: 190, turnaround: 264.809524, reponse: 59.428571
    50 threads: runtime: 532 microseconds, context switches: 174, turnaround: 109.607843, response: 26.647059
    100 threads: runtime: 609 microseconds, context switches: 274, turnaround: 61.198020, response: 16.574257

    parallel_cal.c:

    5 threads: runtime: 28842 microseconds, context switches: 2269, turnaround: 8418.666667, response: 25
    10 threads: runtime: 26100 microseconds, context switches: 2142, turnaround: 8076.090909 response: 73.818182
    20 threads: runtime: 22584 microseconds, context switches: 1688, turnaround: 6907.476190, response: 143.761905
    50 threads: runtime: 18224 microseconds, context switches: 1638, turnaround: 5667.098039, response: 384.921569
    100 threads: runtime: 15009 microseconds, context switches: 1568, turnaround: 4648.623762, response: 803.287129

    vector_multiply.c:

    5 threads: runtime: 52 microseconds, context switches: 9, turnaround: 21.833333, response: 16
    10 threads: runtime: 50 microseconds, context switches: 14, turnaround: 25.545455, response: 22.454545
    20 threads: runtime: 50 microseconds, context switches: 24, turnaround: 28.238095, response: 26.714286
    50 threads: runtime: 49 microseconds, context switches: 54, turnaround: 27.666667, response: 26.960784
    100 threads: runtime: 51 microseconds, context switches: 104, turnaround: 29.029703, response: 28.673267

3)
Benchmark Result Analysis:

4)
Collaboration and References:
